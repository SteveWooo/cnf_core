<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node Connections</title>
    <script src="/public/lib/jquery.min.js"></script>
</head>
<body>
    <div>
        <canvas id="topo"></canvas>
    </div>

    <script type="text/javascript">
    var masterStatus = {
        canvas : undefined,
        ctx : undefined,

        buss : {
            kadRangeNodeID : [], // 根据kad距离排序的nodeID
            nodes : {},
            nodeCount : 0,
        }
    }
    function main(){
        // 业务逻辑中控，细节
        var bussinessJob = {
            /**
             * 封装向后端获取节点信息的接口
             */
            getNodeData : function(callback){
                $.ajax({
                    url : '/api/node_status',
                    success : function(res){
                        res = JSON.parse(res);
                        if (res.status == 2000) {
                            // 先处理好节点的位置
                            for(var nodeId in res.nodes) {
                                // 初次处理
                                if (masterStatus.buss.nodes[nodeId] == undefined) {
                                    var node = res.nodes[nodeId];
                                    var index = masterStatus.buss.nodeCount ++ ; // 使用随机编号
                                    // var index = node["number"] // 使用节点的配置编号

                                    var NODE_PER_LINE = 320;
                                    var SIZE = 1
                                    node.feStatus = {
                                        index : index,
                                        width : 3 * SIZE,
                                        height : 3 * SIZE,
                                        centerLocate : {
                                            x : 0,
                                            y : 0
                                        },
                                        color : 'green', // 节点颜色
                                        lineColor : '#ff1', // 连接成功颜色
                                    }

                                    masterStatus.buss.nodes[nodeId] = node;

                                    function updateNodeXY(nid) {
                                        masterStatus.buss.nodes[nid].feStatus.x = 10 * SIZE * (masterStatus.buss.nodes[nid].feStatus.index % NODE_PER_LINE) + 2 * SIZE
                                        masterStatus.buss.nodes[nid].feStatus.y = 10 * SIZE * Math.floor(masterStatus.buss.nodes[nid].feStatus.index / NODE_PER_LINE) + 2 * SIZE

                                        // 给中心点加点随机数，看起来舒服点
                                        var xRandom = Math.random() * masterStatus.buss.nodes[nid].feStatus.width + (masterStatus.buss.nodes[nid].feStatus.width / 2);
                                        var yRandom = Math.random() * masterStatus.buss.nodes[nid].feStatus.height + (masterStatus.buss.nodes[nid].feStatus.height / 2);

                                        masterStatus.buss.nodes[nid].feStatus.x = masterStatus.buss.nodes[nid].feStatus.x + xRandom;
                                        masterStatus.buss.nodes[nid].feStatus.y = masterStatus.buss.nodes[nid].feStatus.y + yRandom;

                                        masterStatus.buss.nodes[nid].feStatus.centerLocate.x = masterStatus.buss.nodes[nid].feStatus.x + masterStatus.buss.nodes[nid].feStatus.width / 2;
                                        masterStatus.buss.nodes[nid].feStatus.centerLocate.y = masterStatus.buss.nodes[nid].feStatus.y +  masterStatus.buss.nodes[nid].feStatus.height / 2;
                                    }
                                    updateNodeXY(nodeId)

                                    /**
                                     * 计算kad环距离
                                     */
                                    //  var insertIndex = 0
                                    // for(var kadIndex=0;kadIndex < masterStatus.buss.kadRangeNodeID.length;kadIndex++) {
                                    //     var newNodeHead = parseInt(nodeId.substring(2, 4), 16)
                                    //     var thisNodeHead = parseInt(masterStatus.buss.kadRangeNodeID[kadIndex].substring(2, 4))

                                    //     if (newNodeHead > thisNodeHead) {
                                    //         insertIndex ++
                                    //         continue 
                                    //     } else {
                                    //         break
                                    //     }
                                    // }
                                    // masterStatus.buss.kadRangeNodeID.splice(insertIndex, 0, nodeId)

                                    // // 遍历更新所有结点的index坐标
                                    // for(var kadIndex=0;kadIndex < masterStatus.buss.kadRangeNodeID.length;kadIndex++) {
                                    //     var nid = masterStatus.buss.kadRangeNodeID[kadIndex]
                                    //     if (masterStatus.buss.nodes[nid] != undefined) {
                                    //         // masterStatus.buss.nodes[nid].feStatus.index = kadIndex // 更新kad坐标
                                    //         // 更新结点xy坐标
                                    //         updateNodeXY(nid)
                                    //     }
                                    // }

                                    continue ;
                                }

                                // 更新连接状态
                                masterStatus.buss.nodes[nodeId].netStatus = res.nodes[nodeId].netStatus;

                                // 消息状态
                                masterStatus.buss.nodes[nodeId].state = res.nodes[nodeId].state;

                                // 节点状态
                                masterStatus.buss.nodes[nodeId].nodeStatus = res.nodes[nodeId].nodeStatus;
                                // masterStatus.buss.nodes[nodeId].buckets = res.nodes[nodesId].buckets;

                            }

                            callback({
                                status : 2000,
                                nodes : res.nodes
                            });
                            return ;
                        }
                    },
                    error : function(e) {
                        callback({
                            status : 5000,
                            error : e
                        });
                        return ;
                    }
                })
            },
            /**
             * 封装把节点画上画布的接口
             */  
            drawNodeInfoToCanvas : function(){
                var ctx = masterStatus.ctx;
                var canvas = masterStatus.canvas;
                ctx.save();

                // 背景
                ctx.fillStyle = "#1ff";
                ctx.fillRect(0, 0, canvas.width(), canvas.height());

                // 画连线
                for(var nodeId in masterStatus.buss.nodes) {
                    var node = masterStatus.buss.nodes[nodeId];
                    // 只画出度即可
                    // var nodeInbound = node.netStatus.nodeConnectionStatus.serviceStatus.inBoundConn
                    if (node.netStatus == undefined) {
                        continue
                    }
                    var nodeOutbound = node.netStatus.nodeConnectionStatus.serviceStatus.outBoundConn || []
                    var nodeNewBucket = node.netStatus.bucketStatus.newBucket || []
                    for(var i=0;i<nodeNewBucket.length;i++) {
                        let targetNode = masterStatus.buss.nodes[nodeNewBucket[i]];
                        if (targetNode == undefined) {
                            // console.log(nodeNewBucket[i])
                            continue 
                        }

                        ctx.strokeStyle = "#99f"; // 未连接上就连蓝色
                        var isConn = false
                        if (node.netStatus.nodeConnectionStatus.serviceStatus.outBoundConnHashMap[targetNode.nodeID] == true || 
                            node.netStatus.nodeConnectionStatus.serviceStatus.inBoundConnHashMap[targetNode.nodeID] == true) {
                            ctx.strokeStyle = node.feStatus.lineColor;// 连接上的就连黄色
                            isConn = true
                        }

                        // if (!isConn) {
                        //     continue 
                        // }

                        // ctx.strokeStyle = "#11f";
                        ctx.lineWidth = 1;
                        ctx.beginPath();

                        // 线条的出发点是本节点的中心
                        ctx.moveTo(node.feStatus.centerLocate.x, node.feStatus.centerLocate.y);

                        // 线条画到目标节点的中心
                        ctx.lineTo(targetNode.feStatus.centerLocate.x, targetNode.feStatus.centerLocate.y);

                        ctx.stroke();
                        ctx.closePath();
                    }

                    // for(var i=0;i<nodeOutbound.length;i++) {
                    //     let targetNode = masterStatus.buss.nodes[nodeOutbound[i].replace("shaked: ", "")];
                    //     if (targetNode == undefined) {
                    //         // console.log(nodeOutbound[i])
                    //         continue 
                    //     }

                    //     ctx.lineWidth = 1;
                    //     ctx.beginPath();

                    //     // 线条的出发点是本节点的中心
                    //     ctx.moveTo(node.feStatus.centerLocate.x, node.feStatus.centerLocate.y);

                    //     // 线条画到目标节点的中心
                    //     ctx.lineTo(targetNode.feStatus.centerLocate.x, targetNode.feStatus.centerLocate.y);

                    //     ctx.stroke();
                    //     ctx.closePath();
                    // }

                    
                }

                // 画节点
                for(var nodeId in masterStatus.buss.nodes) {
                    var node = masterStatus.buss.nodes[nodeId];
                    
                    if (node.nodeStatus == 'normal') {
                        ctx.fillStyle = node.feStatus.color;
                    } else {
                        ctx.fillStyle = "red";
                    }
                    ctx.fillRect(node.feStatus.x, node.feStatus.y, node.feStatus.width, node.feStatus.height);
                }

                // 写lastMsg
                // for (var nodeId in masterStatus.buss.nodes) {
                //     var node = masterStatus.buss.nodes[nodeId];
                //     ctx.fillStyle = "red";
                //     ctx.font = "15px '微软雅黑'";
                //     ctx.textAlign = "left";
                //     ctx.shadowBlur = 10;
                //     ctx.fillText(node.state.lastMsg.length, node.feStatus.x, node.feStatus.y);
                // }

                    // 写Number
                for (var nodeId in masterStatus.buss.nodes) {
                    var node = masterStatus.buss.nodes[nodeId];
                    ctx.fillStyle = "blue";
                    ctx.font = "7px '微软雅黑'";
                    ctx.textAlign = "left";
                    ctx.shadowBlur = 10;
                    // ctx.fillText(node.number, node.feStatus.x, node.feStatus.y);
                }

                ctx.restore();
            },
            /**
             * 全量更新画布上所有状态的函数入口 
             */
            buildTopo : function(callback){
                bussinessJob.getNodeData(function(res) {
                    if (res.status != 2000) {
                        callback && callback({
                            status : res.status,
                            error : res.e
                        });
                        console.error(res.e)
                        return ;
                    }

                    bussinessJob.drawNodeInfoToCanvas();

                    callback && callback({
                        status : res.status
                    });
                })
            },
        }

        // 全局中控
        var masterJob = {
            init : function(){
                masterStatus.canvas = $("#topo");
                // 拉满canvas宽度
                masterStatus.canvas.attr("width", ($(window).get(0).innerWidth) * 0.99);
                masterStatus.canvas.attr("height", "15000px");
                masterStatus.ctx = masterStatus.canvas[0].getContext("2d");

                var doneBuild = true
                setInterval(function(){
                    if (doneBuild = false){
                        return 
                    }
                    doneBuild = false
                    bussinessJob.buildTopo(function(res) {
                        doneBuild = true                        
                    });
                }, 5000)

                // bussinessJob.buildTopo(function(res) {
                        
                // });
            }
        }

        masterJob.init();
    }
    main();
    </script>
</body>
</html>